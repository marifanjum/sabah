<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Social Card Generator</title>
	  <link href="
https://cdn.jsdelivr.net/npm/jameel-noori@1.1.2/jameel-noori.min.css
" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
	  
    <style>
      @font-face {
        font-family: "Pangea Afrikan Trial";
        src: url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.eot");
        src: url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.eot?#iefix") format("embedded-opentype"),
          url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.woff2") format("woff2"),
          url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.woff") format("woff"),
          url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.ttf") format("truetype"),
          url("https://db.onlinewebfonts.com/t/11650c78ba93a8c78b44eff5c3628f9e.svg#Pangea Afrikan Trial") format("svg");
      }
    </style>
  </head>
  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
      function SocialCardGenerator() {
      const { useState, useRef, useEffect } = React;
        const containerRef = useRef(null);
	 
		  const [isAuthenticated, setIsAuthenticated] = useState(() => {
  try {
    const savedAuth = localStorage.getItem('socialCardAuth');
    return savedAuth ? JSON.parse(savedAuth) : false;
  } catch (e) {
    console.error("Failed to load authentication status from localStorage", e);
    return false;
  }
});
        // State variables for collapsing sections
        const [isBackgroundCollapsed, setIsBackgroundCollapsed] = useState(false);
        const [isPresetsCollapsed, setIsPresetsCollapsed] = useState(false);
        const [isImagesCollapsed, setIsImagesCollapsed] = useState(false);
        const [isVignetteCollapsed, setIsVignetteCollapsed] = useState(false);
        const [isLogoCollapsed, setIsLogoCollapsed] = useState(false);
        const [isCanvasCollapsed, setIsCanvasCollapsed] = useState(false);
        const [isFileNameCollapsed, setIsFileNameCollapsed] = useState(false);
        const [vignette, setVignette] = useState({ show: false, x: 0, y: 0, scale: 1 });
        
        
        const [globalBorderColor, setGlobalBorderColor] = useState("#ffffff");
        const [globalBorderSize, setGlobalBorderSize] = useState(4);
        const [images, setImages] = useState([]);
        const [activeImageId, setActiveImageId] = useState(null);
        const [width, setWidth] = useState(1080);
        const [height, setHeight] = useState(1080);
        const [logo, setLogo] = useState({ show: true, position: "top-right" });
        const [fileName, setFileName] = useState("social-card");
        const [background, setBackground] = useState({
          type: 'solid',
          color: '#000000',
          gradient: {
            color1: '#ffffff',
            color2: '#000000',
            direction: 'to bottom right'
          },
          imageSrc: 'bg.png'
        });
		  
        const [presets, setPresets] = useState(null); // Initialize with null
        const [isDraggingEnabled, setIsDraggingEnabled] = useState(true);

        useEffect(() => {
          fetch('presets.json')
            .then(response => response.json())
            .then(data => {
              const savedUserPresets = localStorage.getItem("userPresets");
              const userPresets = savedUserPresets ? JSON.parse(savedUserPresets) : {};
              const combinedPresets = { ...data, ...userPresets };
              setPresets(combinedPresets);
            })
            .catch(error => {
              console.error("Failed to load presets from presets.json", error);
              // Fallback to an empty object if fetch fails
              setPresets({});
            });
        }, []);


        function loadPreset(name) {
          const preset = presets[name];
          if (!preset) {
            alert("Preset not found");
            return;
          }

          setHeadlines(preset.headlines || []);
          setImages(preset.images.map(img => ({
              ...img,
              scale: img.scale !== undefined ? img.scale : 1,
              fitMode: img.fitMode || { top: false, right: false, bottom: false, left: false },
              stretchEnabled: img.stretchEnabled || false,
          })) || []);
          if (preset.width) setWidth(preset.width);
          if (preset.height) setHeight(preset.height);
          if (preset.logo) setLogo(preset.logo);
          if (preset.fileName) setFileName(preset.fileName);
          if (preset.vignette !== undefined) setVignette(preset.vignette);
          if (preset.globalBorderColor) setGlobalBorderColor(preset.globalBorderColor);
          if (preset.globalBorderSize !== undefined) setGlobalBorderSize(preset.globalBorderSize);
          
          if (preset.background) {
            setBackground(preset.background);
          }

          // Update drag state based on preset
          setIsDraggingEnabled(preset.canDrag !== undefined ? preset.canDrag : true);

          alert(`${name} preset loaded!`);
        }

        function savePreset(name) {
          if (!name) {
            alert("Please enter a preset name");
            return;
          }

          const newPreset = {
            headlines, 
            images: images.map(img => ({
                id: img.id,
                src: img.src,
                x: img.x,
                y: img.y,
                scale: img.scale,
                zIndex: img.zIndex,
                borderEnabled: img.borderEnabled,
                stretchEnabled: img.stretchEnabled,
                fitMode: img.fitMode,
            })),
            width, height, logo, fileName, vignette,
            globalBorderColor, globalBorderSize, background
          };

          const updatedPresets = { ...presets, [name]: newPreset };
          setPresets(updatedPresets);
          localStorage.setItem("userPresets", JSON.stringify(updatedPresets));

          alert(`Preset "${name}" saved!`);
        }

        function deletePreset(name) {
          if (!name) {
            alert("Please select a preset to delete");
            return;
          }
          if (presets[name] && presets[name].isDefault) { // Assuming a property to identify default presets
            alert("Default presets cannot be deleted");
            return;
          }

          const updatedPresets = { ...presets };
          delete updatedPresets[name];
          setPresets(updatedPresets);
          localStorage.setItem("userPresets", JSON.stringify(updatedPresets));

          alert(`Preset "${name}" deleted!`);
        }

        function resetPresets() {
          if (!window.confirm("This will delete all your saved presets and restore only the defaults. Continue?")) {
            return;
          }
          fetch('presets.json')
            .then(response => response.json())
            .then(data => {
              setPresets(data);
              localStorage.removeItem("userPresets");
              alert("Presets reset to default!");
            });
        }

        function exportPresets() {
          const json = JSON.stringify(presets, null, 2);
          navigator.clipboard.writeText(json)
            .then(() => alert("All presets copied to clipboard!"))
            .catch(err => console.error("Clipboard copy failed", err));
        }

        function importPresets() {
          const json = prompt("Paste presets JSON here:");
          if (!json) return;
          try {
            const parsed = JSON.parse(json);
            if (typeof parsed !== "object") throw new Error("Invalid format");

            const updatedPresets = { ...presets, ...parsed };
            setPresets(updatedPresets);
            localStorage.setItem("userPresets", JSON.stringify(parsed));

            alert("Presets imported successfully!");
          } catch (e) {
            alert("Invalid presets JSON");
            console.error("Import failed:", e);
          }
        }

        const [headlines, setHeadlines] = useState([{
          id: Date.now(),
          text: "Headline here",
          fontSize: 90,
          lineHeight: 1.2,
          fontFamily: "JameelNooriNastaliq",
          textColor: "#ffffff",
          textPos: { x: 100, y: 200 },
          direction: "rtl",
          textAlign: "right",
          sidelineOffset: 0,
          shadow: { enabled: true, offsetX: 2, offsetY: 2, blur: 6, color: "rgba(0,0,0,0.6)" },
          stroke: { enabled: false, width: 1, color: "#000000" },
          sideline: { show: true, width: 30, gap: 60, height: 0, color: "#ff0000", opacity: 1 },
          isCollapsed: false,
          isLocked: false,
        }]);
        const [expandedHeadlineId, setExpandedHeadlineId] = useState(null);
        const headlineRefs = useRef({});

        function addHeadline() {
          const newHeadline = {
            id: Date.now(),
            text: "New Headline",
            fontSize: 60,
            lineHeight: 1.2,
            fontFamily: "JameelNooriNastaliq",
            textColor: "#ffffff",
            textPos: { x: 100, y: 300 },
            direction: "rtl",
            textAlign: "right",
            sidelineOffset: 0,
            shadow: { enabled: true, offsetX: 2, offsetY: 2, blur: 6, color: "rgba(0,0,0,0.6)" },
            stroke: { enabled: false, width: 1, color: "#000000" },
            sideline: { show: true, width: 30, gap: 60, height: 0, color: "#ff0000", opacity: 1 },
            isCollapsed: false,
            isLocked: false,
          };
          setHeadlines([...headlines, newHeadline]);
        }

        function updateHeadline(id, updatedProps) {
          setHeadlines(current => current.map(h => h.id === id ? { ...h, ...updatedProps } : h));
        }

        function deleteHeadline(id) {
          setHeadlines(current => current.filter(h => h.id !== id));
          if (expandedHeadlineId === id) {
            setExpandedHeadlineId(null);
          }
        }

		  useEffect(() => {
  try {
    localStorage.setItem('socialCardAuth', JSON.stringify(isAuthenticated));
  } catch (e) {
    console.error("Failed to save authentication status to localStorage", e);
  }
}, [isAuthenticated]);
		  

        useEffect(() => {
          try {
            const savedData = localStorage.getItem('socialCardData');
            if (savedData) {
              const parsedData = JSON.parse(savedData);
              if (parsedData.headlines) setHeadlines(parsedData.headlines.map(h => ({
                ...h,
                isLocked: h.isLocked !== undefined ? h.isLocked : false, // Ensure isLocked exists
              })));
              if (parsedData.images) setImages(parsedData.images.map(img => ({
                ...img,
                fitMode: img.fitMode || { top: false, right: false, bottom: false, left: false },
                stretchEnabled: img.stretchEnabled || false,
              })));
              if (parsedData.width) setWidth(parsedData.width);
              if (parsedData.height) setHeight(parsedData.height);
              if (parsedData.logo) setLogo(parsedData.logo);
              if (parsedData.fileName) setFileName(parsedData.fileName);
              if (parsedData.background) setBackground(parsedData.background);
            }
          } catch (e) {
            console.error("Failed to load data from localStorage", e);
          }
        }, []);

        useEffect(() => {
          const dataToSave = {
            headlines, images, width, height, logo, fileName, background
          };
          try {
            localStorage.setItem('socialCardData', JSON.stringify(dataToSave));
          } catch (e) {
            console.error("Failed to save data to localStorage", e);
          }
        }, [headlines, images, width, height, logo, fileName, background]);

        useEffect(() => {
          const handleBeforeUnload = (e) => {
            e.preventDefault();
            e.returnValue = '';
          };
          window.addEventListener('beforeunload', handleBeforeUnload);

          return () => {
            window.removeEventListener('beforeunload', handleBeforeUnload);
          };
        }, []);

        useEffect(() => {
          headlines.forEach(h => {
            const el = headlineRefs.current[h.id];
            if (!el) return;

            const newHeight = el.offsetHeight;

            if ((h.sideline?.height || 0) !== newHeight) {
              updateHeadline(h.id, {
                sideline: { ...h.sideline, height: newHeight }
              });
            }
          });
        }, [headlines, updateHeadline]);

        function onImageUpload(e) {
          const files = e.target.files;
          if (!files) return;
        
          const newImages = Array.from(files).map((file, index) => {
            const img = new Image();
            img.src = URL.createObjectURL(file);
            return new Promise((resolve) => {
              img.onload = () => {
                const newImg = {
                  id: Date.now() + index,
                  src: img.src,
                  x: 0,
                  y: 0,
                  scale: 1,
                  zIndex: images.length + index,
                  borderEnabled: false,
                  fitMode: { top: false, right: false, bottom: false, left: false },
                  originalWidth: img.naturalWidth,
                  originalHeight: img.naturalHeight,
                };
                resolve(newImg);
              };
            });
          });
        
          Promise.all(newImages).then(resolvedImages => {
            setImages([...images, ...resolvedImages]);
          });
        }

        function onBackgroundUpload(e) {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (event) => {
              setBackground({
                ...background,
                type: 'image',
                imageSrc: event.target.result
              });
            };
            reader.readAsDataURL(file);
          }
        }

        function getCoords(e) {
          return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
        }

        function startDragImage(e, id) {
          if (!isDraggingEnabled) return; // New check
          e.preventDefault();
          e.stopPropagation();
          setActiveImageId(id);
          const { x: startX, y: startY } = getCoords(e);
          const img = images.find(im => im.id === id);
          const initX = img.x, initY = img.y;
          const maxZ = Math.max(...images.map(im => im.zIndex));
          setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im));

          function onMove(ev) {
            const { x: currentX, y: currentY } = getCoords(ev);
            setImages((imgs) => imgs.map(im => im.id === id ? { ...im, x: initX + currentX - startX, y: initY + currentY - startY } : im));
          }

          function onUp() {
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup", onUp);
            window.removeEventListener("touchmove", onMove);
            window.removeEventListener("touchend", onUp);
          }
          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
          window.addEventListener("touchmove", onMove);
          window.addEventListener("touchend", onUp);
        }

        function startDragText(e, id) {
          if (!isDraggingEnabled) return; // New check
          e.preventDefault();
          e.stopPropagation();
          const { x: startX, y: startY } = getCoords(e);
          const headline = headlines.find(h => h.id === id);
          const initPos = { ...headline.textPos };

          function onMove(ev) {
            const { x: currentX, y: currentY } = getCoords(ev);
            updateHeadline(id, { textPos: { x: initPos.x + currentX - startX, y: initPos.y + currentY - startY } });
          }
          
          function onUp() {
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup", onUp);
            window.removeEventListener("touchmove", onMove);
            window.removeEventListener("touchend", onUp);
          }
          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
          window.addEventListener("touchmove", onMove);
          window.addEventListener("touchend", onUp);
        }

        function startDragVignette(e) {
          if (!isDraggingEnabled) return; // New check
          e.preventDefault();
          e.stopPropagation();
          const { x: startX, y: startY } = getCoords(e);
          const initX = vignette.x, initY = vignette.y;
          function onMove(ev) {
            const { x: currentX, y: currentY } = getCoords(ev);
            setVignette(v => ({ ...v, x: initX + currentX - startX, y: initY + currentY - startY }));
          }
          function onUp() {
            window.removeEventListener("mousemove", onMove);
            window.removeEventListener("mouseup", onUp);
            window.removeEventListener("touchmove", onMove);
            window.removeEventListener("touchend", onUp);
          }
          window.addEventListener("mousemove", onMove);
          window.addEventListener("mouseup", onUp);
          window.addEventListener("touchmove", onMove);
          window.addEventListener("touchend", onUp);
        }

        function exportAsImage() {
          if (!containerRef.current) return;

          setActiveImageId(null);

          setTimeout(() => {
            const verticalOffset = 3;
            html2canvas(containerRef.current, {
              useCORS: true,
              scale: 1,
              onclone: (clonedDoc) => {
                const clonedLines = clonedDoc.querySelectorAll(".sideline-clone");
                clonedLines.forEach(clonedLine => {
                  const currentTop = parseFloat(clonedLine.style.top || "0");
                  clonedLine.style.top = currentTop + verticalOffset + "px";
                });
              }
            })
              .then((canvas) => {
                const link = document.createElement("a");
                link.download = (fileName && fileName.trim() ? fileName.trim() : "social-card") + ".png";
                link.href = canvas.toDataURL("image/png");
                link.click();
              })
              .catch(err => {
                console.log("export failed:", err);
              });
          }, 0);
        }

        function updateImage(id, updatedProps) {
          setImages(current => current.map(im => im.id === id ? { ...im, ...updatedProps } : im));
        }

                      return {
                backgroundImage: `lifunction updateImageFitMode(id, corner) {
          setImages(current => current.map(im => {
            if (im.id === id) {
              const newFitMode = { ...im.fitMode, [corner]: !im.fitMode[corner] };
              let newX = im.x;
              let newY = im.y;
              let newScale = im.scale;
              
              // Count how many checkboxes are selected
              const selectedCount = Object.values(newFitMode).filter(Boolean).length;
              
              const isStretchedHorizontally = newFitMode.left && newFitMode.right;
              const isStretchedVertically = newFitMode.top && newFitMode.bottom;

              if (selectedCount === 0) {
                  newX = 0;
                  newY = 0;
                  newScale = 1;
              } else if (isStretchedHorizontally && isStretchedVertically) {
                  // Case: All four corners checked - fills the entire canvas (object-fit: cover)
                  const xScale = width / im.originalWidth;
                  const yScale = height / im.originalHeight;
                  newScale = Math.max(xScale, yScale);
                  const newScaledWidth = im.originalWidth * newScale;
                  const newScaledHeight = im.originalHeight * newScale;
                  newX = (width - newScaledWidth) / 2;
                  newY = (height - newScaledHeight) / 2;
              } else if (isStretchedHorizontally) {
                  // Case: Left and Right selected - stretches horizontally
                  newScale = width / im.originalWidth;
                  newX = 0;
                  // Vertical alignment
                  if (newFitMode.top) {
                      newY = 0;
                  } else if (newFitMode.bottom) {
                      const newScaledHeight = im.originalHeight * newScale;
                      newY = height - newScaledHeight;
                  } else {
                      const newScaledHeight = im.originalHeight * newScale;
                      newY = (height - newScaledHeight) / 2;
                  }
              } else if (isStretchedVertically) {
                  // Case: Top and Bottom selected - stretches vertically
                  newScale = height / im.originalHeight;
                  newY = 0;
                  // Horizontal alignment
                  if (newFitMode.left) {
                      newX = 0;
                  } else if (newFitMode.right) {
                      const newScaledWidth = im.originalWidth * newScale;
                      newX = width - newScaledWidth;
                  } else {
                      const newScaledWidth = im.originalWidth * newScale;
                      newX = (width - newScaledWidth) / 2;
                  }
              } else {
                  // Case: Single corner or non-opposite sides - simple alignment
                  newScale = 1;
                  newX = im.x;
                  newY = im.y;
                  if (newFitMode.left) newX = 0;
                  if (newFitMode.right) newX = width - im.originalWidth;
                  if (newFitMode.top) newY = 0;
                  if (newFitMode.bottom) newY = height - im.originalHeight;
              }

              return {
                ...im,
                fitMode: newFitMode,
                x: newX,
                y: newY,
                scale: newScale,
              };
            }
            return im;
          }));
        }
        
        function changeImageScale(id, scale) { 
            const newScale = parseFloat(scale);
            if (!isNaN(newScale)) {
                setImages((imgs) => imgs.map(im => im.id === id ? { ...im, scale: newScale } : im)) 
            }
        }
        
        function changeVignetteScale(scale) {
            const newScale = parseFloat(scale);
            if (!isNaN(newScale)) {
                setVignette(v => ({ ...v, scale: newScale }));
            }
        }

        function bringForward(id) { const maxZ = Math.max(...images.map(im => im.zIndex)); setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im)) }
        function sendBackward(id) { const minZ = Math.min(...images.map(im => im.zIndex)); setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: minZ - 1 } : im)) }
        function deleteImage(id) { setImages((imgs) => imgs.filter(im => im.id !== id)) }
        function selectImage(id) {
          setActiveImageId(id);
          const maxZ = Math.max(...images.map(im => im.zIndex));
          setImages((imgs) => imgs.map(im => im.id === id ? { ...im, zIndex: maxZ + 1 } : im));
        }

        const backgroundStyle = React.useMemo(() => {
          switch (background.type) {
            case 'solid':
              return { backgroundColor: background.color };
            case 'gradient':
near-gradient(${background.gradient.direction}, ${background.gradient.color1}, ${background.gradient.color2})`
              };
            case 'image':
              return {
                backgroundImage: `url('${background.imageSrc}')`,
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                backgroundRepeat: 'no-repeat'
              };
            default:
              return {};
          }
        }, [background]);

        
        function getImageStyle(img) {
          return {
            left: img.x,
            top: img.y,
            transform: `scale(${img.scale})`,
            transformOrigin: 'top left',
            width: img.originalWidth,
            height: img.originalHeight,
          };
        }

        const isStretched = (img) => {
          return img.fitMode.left && img.fitMode.right || img.fitMode.top && img.fitMode.bottom;
        };

		  // Password submission handler
  const handlePasswordSubmit = (e) => {
    e.preventDefault();
    const password = e.target.elements.password.value;
    // ⚠️ Replace "YOUR_PASSWORD" with your actual password
    if (password === "sabah123") {
      setIsAuthenticated(true);
    } else {
      alert("Incorrect password.");
    }
  };

  // Conditional render based on isAuthenticated state
  if (!isAuthenticated) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-200">
        <form onSubmit={handlePasswordSubmit} className="p-8 bg-white rounded-lg shadow-md">
          <h2 className="text-xl font-bold mb-4">Enter Password to Access</h2>
          <inpu            type="password"
            name="password"
            placeholder="Enter password"
            className="w-full px-4 py-2 border rounded-md focus:outline-none focus:ring focus:border-blue-300"
          />
          <button
            type="submit"
            className="mt-4 w-full bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 focus:outline-none focus:ring"
          >
            Submit
          </button>
        </form>
      </div>
    );
  }

  if (!presets) {
    return (
      <div cassName="flex items-center justify-center min-h-screen bg-gray-200">
        <div className="text-lg font-bold">Loading presets...</div>
      </div>
    );
  }

  // 
// ... (all your existing state variables and functions should be above this point)

      return (
        <div className="flex-1 max-w-full mt-6 md:mt-0">
          <div className="sticky top-4">
            <div className="mb-2">Preview (Output size: {width}×{height})</div>
            <div ref={containerRef} className="relative mx-auto bg-black overflow-hidden" style={{ width, height, ...backgroundStyle }}>
              {/* Images */}
              {images.sort((a, b) => a.zIndex - b.zIndex).map(img => (
                <div
                  key={img.id}
                  onMouseDown={e => startDragImage(e, img.id)}
                  onTouchStart={e => startDragImage(e, img.id)}
                  className="absolute"
                  style={{
                    zIndex: img.zIndex,
                    cursor: "grab",
                    ...getImageStyle(img),
                  }}
                >
                  <img
                    src={img.src}
                    alt="Uploaded Image"
                    style={{
                      display: "block",
                      width: "100%",
                      height: "100%",
                      objectFit: isStretched(img) ? 'cover' : 'none',
                      border: img.borderEnabled
                        ? `${globalBorderSize}px solid ${globalBorderColor}`
                        : "none",
                    }}
                  />
                </div>
              ))}
              

              {/* Vignette */}
              {vignette.show && (
                <img
                  src="Vignette.png"
                  alt="Vignette"
                  onMouseDown={startDragVignette}
                  onTouchStart={startDragVignette}
                  style={{
                    position: "absolute",
                    left: vignette.x,
                    top: vignette.y,
                    transform: `scale(${vignette.scale})`,
                    cursor: "grab",
                    width: "100%",
                    height: "100%",
                    zIndex: 100,
                  }}
                />
              )}

              {/* Logo */}
              {logo.show && (
                <img
                  src="sabah-logo.PNG"
                  alt="Logo"
                  style={{
                    position: "absolute",
                    width: 120,
                    height: 60,
                    ...(logo.position === "top-left" ? { left: 30, top: 150 } : {}),
                    ...(logo.position === "top-right" ? { right: 30, top: 150 } : {}),
                    ...(logo.position === "bottom-left" ? { left: 30, bottom: 150 } : {}),
                    ...(logo.position === "bottom-right" ? { right: 30, bottom: 150 } : {}),
                    zIndex: 300,
                  }}
                />
              )}

              {/* Multiple Headlines */}
              {headlines.map(headline => (
                <React.Fragment key={headline.id}>
                  {headline.sideline.show && (
                    <div
                      className="sideline-clone"
                      style={{
                        position: "absolute",
                        left: headline.direction === "ltr" ? headline.sideline.gap : "auto",
                        right: headline.direction === "rtl" ? headline.sideline.gap : "auto",
                        top: headline.textPos.y + (headline.sidelineOffset || 0),
                        height: headline.sideline.height || 0,
                        width: headline.sideline.width,
                        background: headline.sideline.color,
                        opacity: headline.sideline.opacity,
                        pointerEvents: "none",
                        zIndex: 200,
                      }}
                    />
                  )}
                  <div
                    ref={el => headlineRefs.current[headline.id] = el}
                    onMouseDown={e => startDragText(e, headline.id)}
                    onTouchStart={e => startDragText(e, headline.id)}
                    dir={headline.direction}
                    style={{
                      position: "absolute",
                      left: headline.textPos.x,
                      top: headline.textPos.y,
                      fontSize: headline.fontSize,
                      lineHeight: headline.lineHeight,
                      fontFamily: headline.fontFamily,
                      color: headline.textColor,
                      textShadow: headline.shadow.enabled ? `${headline.shadow.offsetX}px ${headline.shadow.offsetY}px ${headline.shadow.blur}px ${headline.shadow.color}` : "none",
                      WebkitTextStroke: headline.stroke.enabled ? `${headline.stroke.width}px ${headline.stroke.color}` : "none",
                      whiteSpace: "pre-wrap",
                      textAlign: headline.textAlign,
                      cursor: "move",
                      zIndex: 200,
                    }}
                  >
                    {headline.text}
                  </div>
                </React.Fragment>
              ))}
            </div>
          </div>
        </div>
      );
    }
      
    // This part should be outside the component function
    ReactDOM.createRoot(document.getElementById("root")).render(<SocialCardGenerator />);

	</script>
  </body>
</html>
		
                                                                            
