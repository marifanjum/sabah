<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Social Card Generator</title>

    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React + ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Optional local Pangea font: put pangea.woff2 next to index.html if you want it to load -->
    <style>
      @font-face {
        font-family: "Pangea";
        src: url("pangea.woff2") format("woff2");
        font-weight: normal;
        font-style: normal;
      }
      /* small defensive rule for Jameel — if user has it installed it'll be used */
      .urdu { font-family: "Jameel Noori Nastaleeq", "Noto Nastaliq Urdu", serif; }
    </style>
  </head>

  <body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
      function SocialCardGenerator() {
        const { useState, useRef, useEffect } = React;

        // Refs & preview container
        const containerRef = useRef(null);

        // Image layer
        const [imageSrc, setImageSrc] = useState(null);
        const [imgScale, setImgScale] = useState(1);
        const [imgOffset, setImgOffset] = useState({ x: 0, y: 0 });

        // Canvas size (export)
        const [width, setWidth] = useState(1080);
        const [height, setHeight] = useState(1080);

        // Text layer
        const [headline, setHeadline] = useState("آپ کی ہیڈ لائن یہاں آئے گی\nدوسری لائن");
        const [fontSize, setFontSize] = useState(72);
        const [lineHeight, setLineHeight] = useState(1.05);
        const [fontFamily, setFontFamily] = useState("Jameel Noori Nastaleeq, serif");
        const [textColor, setTextColor] = useState("#ffffff");
        const [textPos, setTextPos] = useState({ x: 120, y: 200 });
        const [direction, setDirection] = useState("rtl"); // ltr | rtl

        // Shadow
        const [shadow, setShadow] = useState({
          enabled: true,
          offsetX: 2,
          offsetY: 2,
          blur: 8,
          color: "rgba(0,0,0,0.6)",
        });

        // Sideline / blockquote
        const [sideline, setSideline] = useState({
          show: true,
          width: 10,
          color: "#ffdd00",
          gap: 18,
        });

        // Fit mode
        const [fitMode, setFitMode] = useState("cover"); // cover | contain | stretch

        // Export filename
        const [fileName, setFileName] = useState("social-card.png");

        // Logo options
        const [showLogo, setShowLogo] = useState(false);
        const [logoCorner, setLogoCorner] = useState("br"); // tl, tr, bl, br
        const [logoScale, setLogoScale] = useState(0.18); // fraction of canvas width (approx)

        // Dragging state for image & text
        const dragState = useRef({
          draggingImage: false,
          imageStart: { x: 0, y: 0, origX: 0, origY: 0 },
          draggingText: false,
          textStart: { x: 0, y: 0, origX: 0, origY: 0 },
        });

        // ========== image upload ==========
        function onImageUpload(e) {
          const f = e.target.files && e.target.files[0];
          if (!f) return;
          const url = URL.createObjectURL(f);
          setImageSrc(url);
          setImgScale(1);
          setImgOffset({ x: 0, y: 0 });
        }

        // ========== pointer handlers (image) ==========
        function onPointerDownImage(e) {
          if (!imageSrc) return;
          const p = dragState.current;
          p.draggingImage = true;
          p.imageStart = { x: e.clientX, y: e.clientY, origX: imgOffset.x, origY: imgOffset.y };
          window.addEventListener("pointermove", onPointerMoveImage);
          window.addEventListener("pointerup", onPointerUpImage);
        }
        function onPointerMoveImage(e) {
          const p = dragState.current;
          if (!p.draggingImage) return;
          const dx = e.clientX - p.imageStart.x;
          const dy = e.clientY - p.imageStart.y;
          setImgOffset({ x: p.imageStart.origX + dx, y: p.imageStart.origY + dy });
        }
        function onPointerUpImage() {
          const p = dragState.current;
          p.draggingImage = false;
          window.removeEventListener("pointermove", onPointerMoveImage);
          window.removeEventListener("pointerup", onPointerUpImage);
        }

        // ========== pointer handlers (text drag) ==========
        function onPointerDownText(e) {
          // only left-click / primary
          if (e.button !== 0) return;
          const p = dragState.current;
          p.draggingText = true;
          p.textStart = { x: e.clientX, y: e.clientY, origX: textPos.x, origY: textPos.y };
          window.addEventListener("pointermove", onPointerMoveText);
          window.addEventListener("pointerup", onPointerUpText);
        }
        function onPointerMoveText(e) {
          const p = dragState.current;
          if (!p.draggingText) return;
          const dx = e.clientX - p.textStart.x;
          const dy = e.clientY - p.textStart.y;
          setTextPos({ x: p.textStart.origX + dx, y: p.textStart.origY + dy });
        }
        function onPointerUpText() {
          const p = dragState.current;
          p.draggingText = false;
          window.removeEventListener("pointermove", onPointerMoveText);
          window.removeEventListener("pointerup", onPointerUpText);
        }

        // ensure no native drag
        useEffect(() => {
          const el = containerRef.current;
          if (!el) return;
          el.ondragstart = (ev) => ev.preventDefault();
        }, []);

        // ========== load helper ==========
        function loadImage(src) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
          });
        }

        // ========== export (async to await logo load) ==========
        async function exportAsImage() {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext("2d");

            // Clear / background (transparent by default — fill black as earlier behavior)
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // draw main image if present (respect fitMode, scale and offset)
            if (imageSrc) {
              const img = await loadImage(imageSrc);

              // calculate base scale to fit container like CSS object-fit
              const scaleX = canvas.width / img.width;
              const scaleY = canvas.height / img.height;
              let baseScale = 1;
              if (fitMode === "cover") baseScale = Math.max(scaleX, scaleY);
              else if (fitMode === "contain") baseScale = Math.min(scaleX, scaleY);
              else if (fitMode === "stretch") baseScale = 1; // we'll stretch using canvas size below

              if (fitMode === "stretch") {
                const drawW = canvas.width * imgScale;
                const drawH = canvas.height * imgScale;
                const dx = imgOffset.x;
                const dy = imgOffset.y;
                ctx.drawImage(img, dx, dy, drawW, drawH);
              } else {
                const s = baseScale * imgScale;
                const drawW = img.width * s;
                const drawH = img.height * s;
                // center + offset
                const dx = (canvas.width - drawW) / 2 + imgOffset.x;
                const dy = (canvas.height - drawH) / 2 + imgOffset.y;
                ctx.drawImage(img, dx, dy, drawW, drawH);
              }
            }

            // draw logo if requested (load local sabah-logo.PNG)
            let logoImg = null;
            if (showLogo) {
              try {
                logoImg = await loadImage("sabah-logo.PNG");
                // compute desired logo size
                const logoW = canvas.width * logoScale;
                const aspect = logoImg.height / logoImg.width;
                const logoH = logoW * aspect;
                let lx = 0,
                  ly = 0;
                switch (logoCorner) {
                  case "tl":
                    lx = 16;
                    ly = 16;
                    break;
                  case "tr":
                    lx = canvas.width - logoW - 16;
                    ly = 16;
                    break;
                  case "bl":
                    lx = 16;
                    ly = canvas.height - logoH - 16;
                    break;
                  default: // br
                    lx = canvas.width - logoW - 16;
                    ly = canvas.height - logoH - 16;
                    break;
                }
                ctx.drawImage(logoImg, lx, ly, logoW, logoH);
              } catch (err) {
                // If logo load fails, ignore gracefully
                console.warn("Could not load sabah-logo.PNG:", err);
              }
            }

            // draw sideline - depends on text direction and text block geometry
            // We'll compute the text block size roughly using ctx.measureText for first line and multiply by lines/lineHeight for height.
            ctx.save();
            ctx.font = `${fontSize}px ${fontFamily}`;
            ctx.textBaseline = "top";
            ctx.fillStyle = textColor;
            ctx.direction = direction;

            if (shadow.enabled) {
              ctx.shadowColor = shadow.color;
              ctx.shadowBlur = shadow.blur;
              ctx.shadowOffsetX = shadow.offsetX;
              ctx.shadowOffsetY = shadow.offsetY;
            } else {
              ctx.shadowColor = "transparent";
              ctx.shadowBlur = 0;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            }

            const lines = headline.split("\n");
            const blockHeight = lines.length * fontSize * lineHeight;
            // For width measurement, measure the longest line
            let maxLineWidth = 0;
            for (const ln of lines) {
              const m = ctx.measureText(ln).width;
              if (m > maxLineWidth) maxLineWidth = m;
            }

            // draw sideline (no shadow)
            if (sideline.show) {
              ctx.shadowColor = "transparent";
              ctx.fillStyle = sideline.color;
              if (direction === "ltr") {
                // sidebar to left of text
                const sx = textPos.x - sideline.gap - sideline.width;
                ctx.fillRect(sx, textPos.y, sideline.width, blockHeight);
              } else {
                // sidebar to right of text
                const sx = textPos.x + maxLineWidth + sideline.gap;
                ctx.fillRect(sx, textPos.y, sideline.width, blockHeight);
              }
            }

            // draw text lines (apply shadow if enabled)
            ctx.fillStyle = textColor;
            if (shadow.enabled) {
              ctx.shadowColor = shadow.color;
              ctx.shadowBlur = shadow.blur;
              ctx.shadowOffsetX = shadow.offsetX;
              ctx.shadowOffsetY = shadow.offsetY;
            } else {
              ctx.shadowColor = "transparent";
            }

            // draw each line with position and lineHeight
            let ty = textPos.y;
            for (const ln of lines) {
              // For RTL, use fillText with direction set and position as textPos.x
              ctx.fillText(ln, textPos.x, ty);
              ty += fontSize * lineHeight;
            }

            ctx.restore();

            // finally download
            const link = document.createElement("a");
            link.download = fileName && fileName.trim() !== "" ? fileName : "social-card.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
          } catch (err) {
            console.error("Export failed:", err);
            alert("Export failed — check console for details.");
          }
        }

        // ========== Preview helpers: compute logo style ==========
        function getLogoPreviewStyle(previewW, previewH) {
          // previewW and previewH are containerRef dimensions
          const logoW = previewW * logoScale;
          // attempt to read actual image ratio? we'll approximate square if not loaded
          const style = { position: "absolute", width: logoW + "px", height: "auto" };
          const padding = 12;
          if (logoCorner === "tl") {
            style.left = padding + "px";
            style.top = padding + "px";
          } else if (logoCorner === "tr") {
            style.right = padding + "px";
            style.top = padding + "px";
          } else if (logoCorner === "bl") {
            style.left = padding + "px";
            style.bottom = padding + "px";
          } else {
            style.right = padding + "px";
            style.bottom = padding + "px";
          }
          return style;
        }

        // small utility to get preview size of container (540 width scaled)
        function getPreviewRect() {
          const el = containerRef.current;
          if (!el) return { w: 540, h: Math.round((height / width) * 540) };
          const r = el.getBoundingClientRect();
          return { w: r.width, h: r.height };
        }

        // Render
        return (
          <div className="p-4 max-w-7xl mx-auto">
            <div className="flex gap-6">
              {/* Left: Controls */}
              <div className="w-96 space-y-4">
                <h2 className="text-xl font-semibold">Controls</h2>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Upload image</label>
                  <input type="file" accept="image/*" onChange={onImageUpload} className="mt-2" />
                  <div className="mt-2 text-sm">Tip: drag the image in the preview to reposition it.</div>
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Headline (double-click to edit in textarea)</label>
                  <textarea
                    value={headline}
                    onChange={(e) => setHeadline(e.target.value)}
                    rows={3}
                    className="w-full mt-2 p-2 border rounded"
                  />
                  <div className="grid grid-cols-2 gap-2 mt-2">
                    <div>
                      <label className="text-sm">Font size</label>
                      <input
                        type="range"
                        min="18"
                        max="220"
                        value={fontSize}
                        onChange={(e) => setFontSize(parseInt(e.target.value))}
                        className="w-full"
                      />
                      <div className="text-xs">{fontSize}px</div>
                    </div>
                    <div>
                      <label className="text-sm">Line height</label>
                      <input
                        type="range"
                        min="0.8"
                        max="2.2"
                        step="0.01"
                        value={lineHeight}
                        onChange={(e) => setLineHeight(parseFloat(e.target.value))}
                        className="w-full"
                      />
                      <div className="text-xs">{lineHeight}</div>
                    </div>
                  </div>

                  <div className="mt-2">
                    <label className="text-sm">Font family</label>
                    <select
                      value={fontFamily}
                      onChange={(e) => setFontFamily(e.target.value)}
                      className="w-full mt-1 p-1 border rounded"
                    >
                      <option value="Jameel Noori Nastaleeq, serif">Jameel Noori Nastaleeq</option>
                      <option value="Pangea, Inter, Arial, sans-serif">Pangea</option>
                      <option value="Inter, Arial, sans-serif">Inter</option>
                    </select>
                  </div>

                  <div className="mt-2 grid grid-cols-2 gap-2">
                    <div>
                      <label className="text-sm">Text color</label>
                      <input
                        type="color"
                        value={textColor}
                        onChange={(e) => setTextColor(e.target.value)}
                        className="w-full h-8 p-0 border-0"
                      />
                    </div>
                    <div>
                      <label className="text-sm">Direction</label>
                      <select
                        value={direction}
                        onChange={(e) => setDirection(e.target.value)}
                        className="w-full mt-1 p-1 border rounded"
                      >
                        <option value="rtl">Right-to-left (RTL)</option>
                        <option value="ltr">Left-to-right (LTR)</option>
                      </select>
                    </div>
                  </div>
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Drop shadow</label>
                  <div className="flex gap-2 items-center mt-2">
                    <input
                      type="checkbox"
                      checked={shadow.enabled}
                      onChange={(e) => setShadow({ ...shadow, enabled: e.target.checked })}
                    />
                    <span className="text-sm">enabled</span>
                  </div>
                  <div className="grid grid-cols-3 gap-2 mt-2">
                    <input
                      type="number"
                      value={shadow.offsetX}
                      onChange={(e) => setShadow({ ...shadow, offsetX: parseInt(e.target.value) || 0 })}
                      className="p-1 border rounded"
                    />
                    <input
                      type="number"
                      value={shadow.offsetY}
                      onChange={(e) => setShadow({ ...shadow, offsetY: parseInt(e.target.value) || 0 })}
                      className="p-1 border rounded"
                    />
                    <input
                      type="number"
                      value={shadow.blur}
                      onChange={(e) => setShadow({ ...shadow, blur: parseInt(e.target.value) || 0 })}
                      className="p-1 border rounded"
                    />
                  </div>
                  <div className="mt-2">
                    <input
                      type="color"
                      value={rgbaToHex(shadow.color)}
                      onChange={(e) => setShadow({ ...shadow, color: e.target.value })}
                      className="w-full h-8 p-0 border-0"
                    />
                  </div>
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Sideline / blockquote</label>
                  <div className="mt-2 flex items-center gap-2">
                    <input
                      type="checkbox"
                      checked={sideline.show}
                      onChange={(e) => setSideline({ ...sideline, show: e.target.checked })}
                    />
                    <span className="text-sm">Show sideline</span>
                  </div>
                  {sideline.show && (
                    <div className="mt-2 grid grid-cols-2 gap-2">
                      <div>
                        <label className="text-xs">Width</label>
                        <input
                          type="range"
                          min="2"
                          max="60"
                          value={sideline.width}
                          onChange={(e) => setSideline({ ...sideline, width: parseInt(e.target.value) })}
                          className="w-full"
                        />
                        <div className="text-xs">{sideline.width}px</div>
                      </div>
                      <div>
                        <label className="text-xs">Gap</label>
                        <input
                          type="range"
                          min="0"
                          max="140"
                          value={sideline.gap}
                          onChange={(e) => setSideline({ ...sideline, gap: parseInt(e.target.value) })}
                          className="w-full"
                        />
                        <div className="text-xs">{sideline.gap}px</div>
                      </div>
                      <div className="col-span-2">
                        <label className="text-xs">Color</label>
                        <input
                          type="color"
                          value={sideline.color}
                          onChange={(e) => setSideline({ ...sideline, color: e.target.value })}
                          className="w-full h-8 p-0 border-0"
                        />
                      </div>
                    </div>
                  )}
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm">Fit mode</label>
                  <select value={fitMode} onChange={(e) => setFitMode(e.target.value)} className="w-full mt-1 p-1 border rounded">
                    <option value="cover">Cover</option>
                    <option value="contain">Contain</option>
                    <option value="stretch">Stretch</option>
                  </select>

                  <label className="block text-sm mt-2">Image scale</label>
                  <input
                    type="range"
                    min="0.2"
                    max="3"
                    step="0.01"
                    value={imgScale}
                    onChange={(e) => setImgScale(parseFloat(e.target.value))}
                    className="w-full"
                  />
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <div>Canvas size</div>
                  <div className="flex gap-2 mt-2">
                    <button
                      onClick={() => {
                        setWidth(1080);
                        setHeight(1080);
                      }}
                      className="px-2 py-1 border rounded"
                    >
                      Instagram square
                    </button>
                    <button
                      onClick={() => {
                        setWidth(1080);
                        setHeight(1920);
                      }}
                      className="px-2 py-1 border rounded"
                    >
                      Story 9:16
                    </button>
                  </div>
                  <div className="mt-2">Custom: <input type="number" value={width} onChange={(e) => setWidth(parseInt(e.target.value) || 1080)} className="w-24 inline-block p-1 border rounded" /> × <input type="number" value={height} onChange={(e) => setHeight(parseInt(e.target.value) || 1080)} className="w-24 inline-block p-1 border rounded" /></div>
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Logo (sabah-logo.PNG)</label>
                  <div className="flex items-center gap-2">
                    <input type="checkbox" checked={showLogo} onChange={(e) => setShowLogo(e.target.checked)} />
                    <span className="text-sm">Show logo</span>
                  </div>
                  {showLogo && (
                    <>
                      <div className="mt-2">
                        <label className="text-xs">Corner</label>
                        <select value={logoCorner} onChange={(e) => setLogoCorner(e.target.value)} className="w-full p-1 border rounded">
                          <option value="tl">Top-left</option>
                          <option value="tr">Top-right</option>
                          <option value="bl">Bottom-left</option>
                          <option value="br">Bottom-right</option>
                        </select>
                      </div>
                      <div className="mt-2">
                        <label className="text-xs">Logo size (fraction)</label>
                        <input type="range" min="0.06" max="0.35" step="0.01" value={logoScale} onChange={(e) => setLogoScale(parseFloat(e.target.value))} className="w-full" />
                        <div className="text-xs">{Math.round(logoScale * 100)}% of width</div>
                      </div>
                    </>
                  )}
                </div>

                <div className="bg-white p-3 rounded shadow">
                  <label className="block text-sm font-medium">Export file name</label>
                  <input type="text" value={fileName} onChange={(e) => setFileName(e.target.value)} className="w-full mt-1 p-1 border rounded" />
                </div>

                <div className="flex gap-2">
                  <button onClick={exportAsImage} className="flex-1 bg-blue-600 text-white py-2 rounded">Export PNG</button>
                </div>
              </div>

              {/* Right: Preview */}
              <div className="flex-1">
                <div className="mb-2">Preview (drag image to reposition, drag text to move). Output size: {width}×{height}</div>

                <div ref={containerRef} className="relative mx-auto bg-black" style={{ width: 540, height: Math.round((height / width) * 540) }}>
                  {/* Image layer (pointer down to drag) */}
                  <div
                    onPointerDown={onPointerDownImage}
                    style={{
                      position: "absolute",
                      top: 0,
                      left: 0,
                      right: 0,
                      bottom: 0,
                      overflow: "hidden",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      touchAction: "none",
                    }}
                  >
                    {imageSrc ? (
                      <img
                        src={imageSrc}
                        alt="uploaded"
                        draggable={false}
                        style={{
                          transform: `translate(${imgOffset.x}px, ${imgOffset.y}px) scale(${imgScale})`,
                          transformOrigin: "center",
                          userSelect: "none",
                          maxWidth: fitMode === "contain" ? "100%" : "none",
                          maxHeight: fitMode === "contain" ? "100%" : "none",
                          width: fitMode === "stretch" ? "100%" : undefined,
                          height: fitMode === "stretch" ? "100%" : undefined,
                          cursor: "grab",
                        }}
                      />
                    ) : (
                      <div className="flex items-center justify-center text-gray-400 h-full">No image — upload one or use background color</div>
                    )}
                  </div>

                  {/* Sideline */}
                  {sideline.show && (
                    <div
                      style={{
                        position: "absolute",
                        left: direction === "ltr" ? textPos.x - sideline.gap - sideline.width : "auto",
                        right: direction === "rtl" ? Math.max(0, 540 - textPos.x) + sideline.gap : "auto",
                        top: textPos.y,
                        width: sideline.width,
                        bottom: "auto",
                        height: "auto",
                        minHeight: 40,
                        background: sideline.color,
                        pointerEvents: "none",
                      }}
                    />
                  )}

                  {/* Draggable text */}
                  <div
                    onPointerDown={onPointerDownText}
                    onDoubleClick={() => {
                      /* optional: focus textarea in controls */
                      const ta = document.querySelector("textarea");
                      if (ta) ta.focus();
                    }}
                    style={{
                      position: "absolute",
                      left: textPos.x,
                      top: textPos.y,
                      minWidth: 120,
                      maxWidth: 540 - 40,
                      fontSize: fontSize,
                      lineHeight: lineHeight,
                      fontFamily: fontFamily,
                      color: textColor,
                      whiteSpace: "pre-wrap",
                      textAlign: direction === "rtl" ? "right" : "left",
                      direction: direction,
                      textShadow: shadow.enabled ? `${shadow.offsetX}px ${shadow.offsetY}px ${shadow.blur}px ${shadow.color}` : "none",
                      cursor: "move",
                      userSelect: "none",
                      padding: 8,
                    }}
                  >
                    {headline}
                  </div>

                  {/* Logo preview (if enabled) */}
                  {showLogo && (
                    <img
                      src="sabah-logo.PNG"
                      alt="logo"
                      style={{
                        position: "absolute",
                        ...(
                          logoCorner === "tl" ? { left: 12, top: 12 } :
                            logoCorner === "tr" ? { right: 12, top: 12 } :
                              logoCorner === "bl" ? { left: 12, bottom: 12 } :
                                { right: 12, bottom: 12 }
                        ),
                        width: (540 * logoScale) + "px",
                        height: "auto",
                        pointerEvents: "none",
                        opacity: 1,
                      }}
                    />
                  )}
                </div>

                <div className="mt-2 text-xs text-gray-500">Tip: drag the headline to reposition it; use controls on the left for fonts, shadow, sidebar and export.</div>
              </div>
            </div>
          </div>
        );
      }

      // small helpers for color conversion used in controls
      function rgbaToHex(rgba) {
        // if input is hex already, return as-is
        if (!rgba) return "#000000";
        if (rgba.startsWith("#")) return rgba;
        const m = rgba.match(/rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)/);
        if (!m) return "#000000";
        const r = parseInt(m[1]).toString(16).padStart(2, "0");
        const g = parseInt(m[2]).toString(16).padStart(2, "0");
        const b = parseInt(m[3]).toString(16).padStart(2, "0");
        return `#${r}${g}${b}`;
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<SocialCardGenerator />);
    </script>
  </body>
</html>
