<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Image Manipulation</title>
<style>
  body { margin: 5px; font-family: Arial, sans-serif; }
  button { padding: 12px 20px; margin: 8px; font-size: 18px; }
  #canvasContainer { position: relative; width: 1200px; height: 720px; border: 2px solid black; overflow: hidden; margin-bottom: 20px; }
  #canvas { position: absolute; top: 0; left: 0; cursor: move; }
  label { font-size: 16px; margin-right: 12px; display: inline-block; }
  .small { font-size: 14px; margin-left: 6px; }
  .controls-row { margin-bottom: 10px; }
  input[type="text"] { padding: 6px; font-size: 16px; margin-left: 10px; width: 250px; }
</style>
</head>
<body>

  <div id="canvasContainer">
    <canvas id="canvas" width="1200" height="720"></canvas>
  </div>

  <div class="controls-row">
    <button id="stretchButton">Fit by Stretch Short Side</button>
    <button id="fitLongestSideButton">Fit on Longest Side</button>
    <button id="centerButton">Center Image</button>
    <button id="forceStretchButton">Force Stretch to Fit</button>
    <button id="fillCanvasButton">Auto Zoom to Fill</button>
  </div>

  <div class="controls-row">
    <label><input type="checkbox" id="toggleBorder" checked> Show Border</label>
    <label><input type="checkbox" id="toggleLogo" checked> Show Logo</label>
    <label><input type="checkbox" id="toggleBg" checked> Show Background</label>
    <label><input type="checkbox" id="toggleGradient"> Use Gradient Background</label>

    <label>Logo Position:
      <select id="logoPosition" class="small">
        <option value="top-right" selected>Top Right</option>
        <option value="top-left">Top Left</option>
        <option value="bottom-right">Bottom Right</option>
        <option value="bottom-left">Bottom Left</option>
      </select>
    </label>
  </div>

  <div class="controls-row">
    <label>Gradient Color Right: <input type="color" id="gradColor2" value="#ffffff"></label>
    <label>Gradient Color Left: <input type="color" id="gradColor1" value="#000000"></label>
  
    <label>Direction:
      <select id="gradDirection" class="small">
        <option value="top-bottom">Top → Bottom</option>
        <option value="bottom-top">Bottom → Top</option>
        <option value="left-right">Left → Right</option>
        <option value="right-left">Right → Left</option>
        <option value="tl-br">Top-Left → Bottom-Right</option>
        <option value="tr-bl">Top-Right → Bottom-Left</option>
        <option value="bl-tr">Bottom-Left → Top-Right</option>
        <option value="br-tl">Bottom-Right → Top-Left</option>
      </select>
    </label>
  </div>

  <div class="controls-row">
    <input type="file" id="imageInput" accept="image/*">
  </div>

  <div class="controls-row">
    <label>Filename: <input type="text" id="fileNameInput" placeholder="Enter filename (optional)"></label>
    <button id="downloadCanvasButton">Download Resized Image</button>
  </div>

<script>
/* Restored pan & zoom, pinch gestures, plus filename input for download.
   - offsetX, offsetY are image top-left coords (canvas pixels).
   - scale multiplies image natural width/height when drawing.
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const imageInput = document.getElementById('imageInput');
const stretchButton = document.getElementById('stretchButton');
const fitLongestSideButton = document.getElementById('fitLongestSideButton');
const centerButton = document.getElementById('centerButton');
const forceStretchButton = document.getElementById('forceStretchButton');
const fillCanvasButton = document.getElementById('fillCanvasButton');
const downloadCanvasButton = document.getElementById('downloadCanvasButton');
const fileNameInput = document.getElementById('fileNameInput');

const toggleBorder = document.getElementById('toggleBorder');
const toggleLogo = document.getElementById('toggleLogo');
const toggleBg = document.getElementById('toggleBg');
const toggleGradient = document.getElementById('toggleGradient');

const gradColor1 = document.getElementById('gradColor1');
const gradColor2 = document.getElementById('gradColor2');
const gradDirection = document.getElementById('gradDirection');
const logoPosition = document.getElementById('logoPosition');

let image = null;
let logo = new Image();
logo.src = "sabah-logo.PNG";

let bgImage = new Image();
bgImage.src = "image-bg.png";

let offsetX = 0, offsetY = 0;
let scale = 1;
let forceStretchMode = false;

const MIN_SCALE = 0.05;
const MAX_SCALE = 20;

// dragging state (mouse)
let isDragging = false;
let dragStartX = 0, dragStartY = 0;

// touch/pinch state
let lastTouchDistance = 0;
let lastTouchCenter = null;

// --- helpers ---
function toCanvasCoords(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  return {
    x: (clientX - rect.left) * (canvas.width / rect.width),
    y: (clientY - rect.top) * (canvas.height / rect.height)
  };
}

// --- image load / paste handlers ---
const handleFileChange = e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => loadImage(ev.target.result);
  reader.readAsDataURL(file);
};

const loadImage = src => {
  image = new Image();
  image.onload = function() {
    fitImageToCanvas();
  };
  image.onerror = function() {
    console.warn('Image failed to load:', src);
    image = null;
    drawImage();
  };
  image.src = src;
};

// support paste event (Ctrl+V / ⌘+V)
document.addEventListener("paste", e => {
  if (e.clipboardData) {
    const items = e.clipboardData.items;
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.indexOf("image") !== -1) {
        const file = items[i].getAsFile();
        const reader = new FileReader();
        reader.onload = ev => loadImage(ev.target.result);
        reader.readAsDataURL(file);
        e.preventDefault();
        return;
      }
    }
  }
});

// --- utility: create a canvas gradient from direction ---
function createCanvasGradient(direction, colorA, colorB) {
  let x0=0, y0=0, x1=0, y1=0;
  switch (direction) {
    case 'top-bottom':     x0 = 0; y0 = 0; x1 = 0; y1 = canvas.height; break;
    case 'bottom-top':     x0 = 0; y0 = canvas.height; x1 = 0; y1 = 0; break;
    case 'left-right':     x0 = 0; y0 = 0; x1 = canvas.width; y1 = 0; break;
    case 'right-left':     x0 = canvas.width; y0 = 0; x1 = 0; y1 = 0; break;
    case 'tl-br':          x0 = 0; y0 = 0; x1 = canvas.width; y1 = canvas.height; break;
    case 'tr-bl':          x0 = canvas.width; y0 = 0; x1 = 0; y1 = canvas.height; break;
    case 'bl-tr':          x0 = 0; y0 = canvas.height; x1 = canvas.width; y1 = 0; break;
    case 'br-tl':          x0 = canvas.width; y0 = canvas.height; x1 = 0; y1 = 0; break;
    default:               x0 = 0; y0 = 0; x1 = 0; y1 = canvas.height;
  }
  const g = ctx.createLinearGradient(x0, y0, x1, y1);
  g.addColorStop(0, colorA);
  g.addColorStop(1, colorB);
  return g;
}

// --- draw all layers ---
const drawImage = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (toggleBg.checked && bgImage.complete && bgImage.naturalWidth > 0) {
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  }
  else if (!toggleBg.checked && toggleGradient.checked) {
    ctx.fillStyle = createCanvasGradient(gradDirection.value, gradColor1.value, gradColor2.value);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else {
    // default background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  if (image) {
    if (forceStretchMode) {
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.drawImage(image, offsetX, offsetY, image.width * scale, image.height * scale);
    }
  }

  if (toggleBorder.checked) {
    ctx.strokeStyle = "grey";
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
    ctx.strokeRect(14, 14, canvas.width - 28, canvas.height - 28);
  }

  if (toggleLogo.checked && logo.complete && logo.naturalWidth > 0) {
    const logoWidth = 120, logoHeight = 60;
    let x = 0, y = 0;
    switch (logoPosition.value) {
      case 'top-left':     x = 20; y = 50; break;
      case 'top-right':    x = canvas.width - logoWidth - 20; y = 50; break;
      case 'bottom-left':  x = 20; y = canvas.height - logoHeight - 20; break;
      case 'bottom-right': x = canvas.width - logoWidth - 20; y = canvas.height - logoHeight - 20; break;
    }
    ctx.drawImage(logo, x, y, logoWidth, logoHeight);
  }
};

// --- fit / layout functions ---
const fitImageToCanvas = () => {
  if (!image) return;
  // center and fit (contain)
  scale = Math.min(canvas.width / image.width, canvas.height / image.height);
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};

const fitByStretch = () => { fitImageToCanvas(); };
const fitOnLongestSide = () => {
  if (!image) return;
  if (image.width > image.height) scale = canvas.width / image.width;
  else scale = canvas.height / image.height;
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};
const centerImage = () => {
  if (!image) return;
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};
const forceStretch = () => { forceStretchMode = true; drawImage(); };
const fillCanvas = () => {
  if (!image) return;
  scale = Math.max(canvas.width / image.width, canvas.height / image.height);
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};

// --- input events for pan/zoom ---

// mouse drag start
canvas.addEventListener('mousedown', (e) => {
  if (!image || forceStretchMode) return;
  const p = toCanvasCoords(e.clientX, e.clientY);
  isDragging = true;
  // we'll compute offset so that offsetX = clientX - startX pattern works on move
  dragStartX = p.x - offsetX;
  dragStartY = p.y - offsetY;
  canvas.style.cursor = 'grabbing';
});

// mouse move
window.addEventListener('mousemove', (e) => {
  if (!isDragging || !image || forceStretchMode) return;
  const p = toCanvasCoords(e.clientX, e.clientY);
  offsetX = p.x - dragStartX;
  offsetY = p.y - dragStartY;
  drawImage();
});

// mouse up
window.addEventListener('mouseup', () => {
  if (isDragging) {
    isDragging = false;
    canvas.style.cursor = 'move';
  }
});

// wheel zoom (centered at pointer)
canvas.addEventListener('wheel', (e) => {
  if (!image || forceStretchMode) return;
  e.preventDefault();
  const p = toCanvasCoords(e.clientX, e.clientY);
  const prevScale = scale;
  const zoomFactor = (e.deltaY < 0) ? 1.12 : 0.88;
  scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * zoomFactor));
  // keep the point under cursor stable
  offsetX = p.x - (p.x - offsetX) * (scale / prevScale);
  offsetY = p.y - (p.y - offsetY) * (scale / prevScale);
  drawImage();
}, { passive: false });

// touch handlers: pan with one finger, pinch with two
canvas.addEventListener('touchstart', (e) => {
  if (!image || forceStretchMode) return;
  if (e.touches.length === 1) {
    const p = toCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    isDragging = true;
    dragStartX = p.x - offsetX;
    dragStartY = p.y - offsetY;
  } else if (e.touches.length === 2) {
    // start pinch
    const t0 = e.touches[0], t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    lastTouchDistance = Math.hypot(dx, dy);
    // center point in canvas coordinates
    const cx = (t0.clientX + t1.clientX) / 2;
    const cy = (t0.clientY + t1.clientY) / 2;
    lastTouchCenter = toCanvasCoords(cx, cy);
  }
}, { passive:false });

canvas.addEventListener('touchmove', (e) => {
  if (!image || forceStretchMode) return;
  if (e.touches.length === 1 && isDragging) {
    e.preventDefault();
    const p = toCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
    offsetX = p.x - dragStartX;
    offsetY = p.y - dragStartY;
    drawImage();
  } else if (e.touches.length === 2) {
    e.preventDefault();
    const t0 = e.touches[0], t1 = e.touches[1];
    const dx = t1.clientX - t0.clientX;
    const dy = t1.clientY - t0.clientY;
    const dist = Math.hypot(dx, dy);
    if (lastTouchDistance > 0) {
      const prevScale = scale;
      let newScale = prevScale * (dist / lastTouchDistance);
      newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, newScale));
      // center point between fingers in canvas coords
      const cx = (t0.clientX + t1.clientX) / 2;
      const cy = (t0.clientY + t1.clientY) / 2;
      const center = toCanvasCoords(cx, cy);
      offsetX = center.x - (center.x - offsetX) * (newScale / prevScale);
      offsetY = center.y - (center.y - offsetY) * (newScale / prevScale);
      scale = newScale;
      drawImage();
    }
    lastTouchDistance = dist;
  }
}, { passive:false });

canvas.addEventListener('touchend', (e) => {
  if (e.touches.length < 2) lastTouchDistance = 0;
  if (e.touches.length === 0) isDragging = false;
}, { passive:true });

// double-click/double-tap to center
canvas.addEventListener('dblclick', (e) => {
  centerImage();
});

// download
const downloadCanvas = () => {
  let filename = fileNameInput.value.trim();
  if (filename === "") filename = "resized";
  if (!filename.toLowerCase().endsWith(".webp")) filename += ".webp";

  const link = document.createElement('a');
  link.download = filename;
  link.href = canvas.toDataURL('image/webp', 0.95);
  link.click();
};

// --- events binding ---
imageInput.addEventListener('change', handleFileChange);
stretchButton.addEventListener('click', fitByStretch);
fitLongestSideButton.addEventListener('click', fitOnLongestSide);
centerButton.addEventListener('click', centerImage);
forceStretchButton.addEventListener('click', forceStretch);
fillCanvasButton.addEventListener('click', fillCanvas);
downloadCanvasButton.addEventListener('click', downloadCanvas);

toggleBorder.addEventListener('change', drawImage);
toggleLogo.addEventListener('change', drawImage);
toggleBg.addEventListener('change', drawImage);
toggleGradient.addEventListener('change', drawImage);
gradColor1.addEventListener('input', drawImage);
gradColor2.addEventListener('input', drawImage);
gradDirection.addEventListener('change', drawImage);
logoPosition.addEventListener('change', drawImage);

bgImage.onload = drawImage;
logo.onload = drawImage;

// initial blank draw
drawImage();
</script>
</body>
</html>
