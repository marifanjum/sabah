<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Image Manipulation</title>
<style>
  body { margin: 5px; font-family: Arial, sans-serif; }
  button { padding: 12px 20px; margin: 8px; font-size: 18px; }
  #canvasContainer { position: relative; width: 1200px; height: 720px; border: 2px solid black; overflow: hidden; margin-bottom: 20px; }
  #canvas { position: absolute; top: 0; left: 0; cursor: move; }
  label { font-size: 16px; margin-right: 12px; display: inline-block; }
  .small { font-size: 14px; margin-left: 6px; }
  .controls-row { margin-bottom: 10px; }
</style>
</head>
<body>

  <div id="canvasContainer">
    <canvas id="canvas" width="1200" height="720"></canvas>
  </div>

  <div class="controls-row">
    <button id="stretchButton">Fit by Stretch Short Side</button>
    <button id="fitLongestSideButton">Fit on Longest Side</button>
    <button id="centerButton">Center Image</button>
    <button id="forceStretchButton">Force Stretch to Fit</button>
    <button id="fillCanvasButton">Auto Zoom to Fill</button>
    <button id="downloadCanvasButton">Download Resized Image</button>
  </div>

  <div class="controls-row">
    <label><input type="checkbox" id="toggleBorder" checked> Show Border</label>
    <label><input type="checkbox" id="toggleLogo" checked> Show Logo</label>
    <label><input type="checkbox" id="toggleBg" checked> Show Background</label>
    <label><input type="checkbox" id="toggleGradient"> Use Gradient Background</label>

    <label>Logo Position:
      <select id="logoPosition" class="small">
        <option value="top-right" selected>Top Right</option>
        <option value="top-left">Top Left</option>
        <option value="bottom-right">Bottom Right</option>
        <option value="bottom-left">Bottom Left</option>
      </select>
    </label>
  </div>

  <div class="controls-row">
      <label>Gradient Color Right: <input type="color" id="gradColor2" value="#ffffff"></label>
    <label>Gradient Color Left: <input type="color" id="gradColor1" value="#000000"></label>
  
    <label>Direction:
      <select id="gradDirection" class="small">
        <option value="top-bottom">Top → Bottom</option>
        <option value="bottom-top">Bottom → Top</option>
        <option value="left-right">Left → Right</option>
        <option value="right-left">Right → Left</option>
        <option value="tl-br">Top-Left → Bottom-Right</option>
        <option value="tr-bl">Top-Right → Bottom-Left</option>
        <option value="bl-tr">Bottom-Left → Top-Right</option>
        <option value="br-tl">Bottom-Right → Top-Left</option>
      </select>
    </label>
  </div>

  <div class="controls-row">
    <input type="file" id="imageInput" accept="image/*">
  </div>

<script>

  <!-- Add these inputs and button somewhere in your HTML -->
<div class="controls-row">
  <input type="text" id="titleInput" placeholder="Enter Title (English)">
  <input type="text" id="captionInput" placeholder="اردو کیپشن درج کریں">
  <button id="downloadWithMeta">Download with Title & Caption</button>
</div>

<script type="module">
import initWasm, { ExifTool } from "https://cdn.jsdelivr.net/npm/exiftool-wasm@0.1.5/+esm";

// Reuse your existing canvas
const downloadWithMetaBtn = document.getElementById("downloadWithMeta");
const titleInput = document.getElementById("titleInput");
const captionInput = document.getElementById("captionInput");

downloadWithMetaBtn.addEventListener("click", async () => {
  const title = titleInput.value.trim();
  const caption = captionInput.value.trim();

  if (!title && !caption) {
    alert("Please enter a title or caption before downloading.");
    return;
  }

  // Capture canvas as JPEG
  const blob = await new Promise(res => canvas.toBlob(res, "image/jpeg", 0.9));
  const arrayBuffer = await blob.arrayBuffer();
  const uint8 = new Uint8Array(arrayBuffer);

  // Init exiftool-wasm
  await initWasm();
  const exiftool = new ExifTool();

  // Inject metadata (UTF-8 safe)
  const withMeta = await exiftool.write(uint8, {
    "XMP-dc:Title": title,
    "XMP-dc:Description": caption,
    "IPTC:Caption-Abstract": caption
  });

  // Save result
  const outBlob = new Blob([withMeta], { type: "image/jpeg" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(outBlob);
  a.download = "canvas-with-meta.jpg";
  a.click();
});


  
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const imageInput = document.getElementById('imageInput');
const stretchButton = document.getElementById('stretchButton');
const fitLongestSideButton = document.getElementById('fitLongestSideButton');
const centerButton = document.getElementById('centerButton');
const forceStretchButton = document.getElementById('forceStretchButton');
const fillCanvasButton = document.getElementById('fillCanvasButton');
const downloadCanvasButton = document.getElementById('downloadCanvasButton');

const toggleBorder = document.getElementById('toggleBorder');
const toggleLogo = document.getElementById('toggleLogo');
const toggleBg = document.getElementById('toggleBg');
const toggleGradient = document.getElementById('toggleGradient');

const gradColor1 = document.getElementById('gradColor1');
const gradColor2 = document.getElementById('gradColor2');
const gradDirection = document.getElementById('gradDirection');
const logoPosition = document.getElementById('logoPosition');

let image = null;
let logo = new Image();
logo.src = "sabah-logo.PNG";

let bgImage = new Image();
bgImage.src = "image-bg.png";

let offsetX = 0, offsetY = 0;
let isDragging = false;
let startX = 0, startY = 0;
let scale = 1;
let forceStretchMode = false;

let lastTouchDistance = 0;
let lastTouchX = 0;
let lastTouchY = 0;

// --- image load / paste handlers ---
const handleFileChange = e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => loadImage(ev.target.result);
  reader.readAsDataURL(file);
};

const loadImage = src => {
  image = new Image();
  image.onload = function() {
    fitImageToCanvas();
  };
  image.src = src;
};

const handlePaste = event => {
  const items = (event.clipboardData || event.originalEvent && event.originalEvent.clipboardData).items;
  for (let i=0; i<items.length; i++){
    const item = items[i];
    if (item.kind === 'file' && item.type.indexOf('image') !== -1){
      const blob = item.getAsFile();
      const reader = new FileReader();
      reader.onload = ev => loadImage(ev.target.result);
      reader.readAsDataURL(blob);
      break;
    }
  }
};

// --- utility: create a canvas gradient from direction ---
function createCanvasGradient(direction, colorA, colorB) {
  let x0=0, y0=0, x1=0, y1=0;
  switch (direction) {
    case 'top-bottom':     x0 = 0; y0 = 0; x1 = 0; y1 = canvas.height; break;
    case 'bottom-top':     x0 = 0; y0 = canvas.height; x1 = 0; y1 = 0; break;
    case 'left-right':     x0 = 0; y0 = 0; x1 = canvas.width; y1 = 0; break;
    case 'right-left':     x0 = canvas.width; y0 = 0; x1 = 0; y1 = 0; break;
    case 'tl-br':          x0 = 0; y0 = 0; x1 = canvas.width; y1 = canvas.height; break;
    case 'tr-bl':          x0 = canvas.width; y0 = 0; x1 = 0; y1 = canvas.height; break;
    case 'bl-tr':          x0 = 0; y0 = canvas.height; x1 = canvas.width; y1 = 0; break;
    case 'br-tl':          x0 = canvas.width; y0 = canvas.height; x1 = 0; y1 = 0; break;
    default:               x0 = 0; y0 = 0; x1 = 0; y1 = canvas.height;
  }
  const g = ctx.createLinearGradient(x0, y0, x1, y1);
  g.addColorStop(0, colorA);
  g.addColorStop(1, colorB);
  return g;
}

// --- draw all layers ---
const drawImage = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (toggleBg.checked && bgImage.complete) {
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  }
  else if (!toggleBg.checked && toggleGradient.checked) {
    ctx.fillStyle = createCanvasGradient(gradDirection.value, gradColor1.value, gradColor2.value);
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  if (image) {
    if (forceStretchMode) {
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
      ctx.drawImage(image, offsetX, offsetY, image.width * scale, image.height * scale);
    }
  }

  if (toggleBorder.checked) {
    ctx.strokeStyle = "grey";
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);
    ctx.strokeRect(14, 14, canvas.width - 28, canvas.height - 28);
  }

  if (toggleLogo.checked && logo.complete) {
    const logoWidth = 120, logoHeight = 60;
    let x = 0, y = 0;
    switch (logoPosition.value) {
      case 'top-left':     x = 20; y = 50; break;
      case 'top-right':    x = canvas.width - logoWidth - 20; y = 50; break;
      case 'bottom-left':  x = 20; y = canvas.height - logoHeight - 20; break;
      case 'bottom-right': x = canvas.width - logoWidth - 20; y = canvas.height - logoHeight - 20; break;
    }
    ctx.drawImage(logo, x, y, logoWidth, logoHeight);
  }
};

// --- fit / layout functions ---
const fitImageToCanvas = () => {
  if (!image) return;
  offsetX = 0; offsetY = 0;
  scale = Math.min(canvas.width / image.width, canvas.height / image.height);
  forceStretchMode = false;
  drawImage();
};

const fitByStretch = () => {
  if (!image) return;
  offsetX = 0; offsetY = 0;
  scale = Math.min(canvas.width / image.width, canvas.height / image.height);
  forceStretchMode = false;
  drawImage();
};

const fitOnLongestSide = () => {
  if (!image) return;
  offsetX = 0; offsetY = 0;
  if (image.width > image.height) scale = canvas.width / image.width;
  else scale = canvas.height / image.height;
  forceStretchMode = false;
  drawImage();
};

const centerImage = () => {
  if (!image) return;
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};

const forceStretch = () => {
  forceStretchMode = true;
  drawImage();
};

// --- new function: auto zoom to fill canvas ---
const fillCanvas = () => {
  if (!image) return;
  scale = Math.max(canvas.width / image.width, canvas.height / image.height);
  offsetX = (canvas.width - image.width * scale) / 2;
  offsetY = (canvas.height - image.height * scale) / 2;
  forceStretchMode = false;
  drawImage();
};

// --- mouse/touch interaction ---
const handleMouseDown = e => {
  if (forceStretchMode) return;
  isDragging = true;
  startX = e.clientX - offsetX;
  startY = e.clientY - offsetY;
};

const handleMouseMove = e => {
  if (!isDragging || forceStretchMode) return;
  offsetX = e.clientX - startX;
  offsetY = e.clientY - startY;
  drawImage();
};

const handleMouseUp = () => { isDragging = false; };

const handleMouseWheel = e => {
  if (forceStretchMode) return;
  e.preventDefault();
  const delta = (e.wheelDelta ? e.wheelDelta : -e.deltaY) > 0 ? 1 : -1;
  const zoomSpeed = 0.1;
  const zoomFactor = 1 + zoomSpeed * delta;
  scale *= zoomFactor;
  drawImage();
};

const handleTouchStart = e => {
  if (forceStretchMode) return;
  if (e.touches.length === 1) {
    lastTouchX = e.touches[0].clientX;
    lastTouchY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    lastTouchDistance = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
  }
};

const handleTouchMove = e => {
  if (forceStretchMode) return;
  if (e.touches.length === 1) {
    e.preventDefault();
    const tx = e.touches[0].clientX;
    const ty = e.touches[0].clientY;
    offsetX += tx - lastTouchX;
    offsetY += ty - lastTouchY;
    lastTouchX = tx; lastTouchY = ty;
    drawImage();
  } else if (e.touches.length === 2) {
    e.preventDefault();
    const touchDistance = Math.hypot(
      e.touches[0].clientX - e.touches[1].clientX,
      e.touches[0].clientY - e.touches[1].clientY
    );
    const zoomFactor = touchDistance / (lastTouchDistance || touchDistance);
    scale *= zoomFactor;
    lastTouchDistance = touchDistance;
    drawImage();
  }
};

const handleTouchEnd = () => { lastTouchDistance = 0; };

// download
const downloadCanvas = () => {
  const link = document.createElement('a');
  link.download = 'resized.webp';
  link.href = canvas.toDataURL('image/webp', 0.5);
  link.click();
};

// --- events binding ---
imageInput.addEventListener('change', handleFileChange);
document.addEventListener('paste', handlePaste);

canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
document.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('wheel', handleMouseWheel);

canvas.addEventListener('touchstart', handleTouchStart, {passive:false});
canvas.addEventListener('touchmove', handleTouchMove, {passive:false});
canvas.addEventListener('touchend', handleTouchEnd);

stretchButton.addEventListener('click', fitByStretch);
fitLongestSideButton.addEventListener('click', fitOnLongestSide);
centerButton.addEventListener('click', centerImage);
forceStretchButton.addEventListener('click', forceStretch);
fillCanvasButton.addEventListener('click', fillCanvas);
downloadCanvasButton.addEventListener('click', downloadCanvas);

toggleBorder.addEventListener('change', drawImage);
toggleLogo.addEventListener('change', drawImage);
toggleBg.addEventListener('change', drawImage);
toggleGradient.addEventListener('change', drawImage);
gradColor1.addEventListener('input', drawImage);
gradColor2.addEventListener('input', drawImage);
gradDirection.addEventListener('change', drawImage);
logoPosition.addEventListener('change', drawImage);

bgImage.onload = drawImage;
logo.onload = drawImage;

drawImage();
</script>
</body>
</html>
